current 当前
original 原文
Complete 完成,完全
Failed 失败

1. 单一职责 - 一个文件只定义一个组件.
2. 把Angular组件包装到一个立即调用的函数表达式中(IIFE).
    把变量从全局作用域中删除, 防止更长的生命周期, 避免冲突, 和压缩合并冲突问题.
3. 避免命名冲突, 每一个独立的子模块使用唯一的命名约定.
4. 不适用任何一个是用来setter语法的变量定义modules. //?
5. 使用module的时候, 避免直接用一个变量, 而是使用getter链式语法.
    这将产生更加易读的代码, 并且可以避免变量冲突和泄露.
6. 回调函数使用命名函数, 不要使用匿名函数.
    易读, 方便调试, 减少嵌套回调函数的数量.
7. 使用containerAs语法代替直接用的$scope定义的controller的方法.
    congtroller被构建的时候, 就会有一个新的实例, controllerAs语法跟接近JavaScript构造函数.
    这促进在View中对绑定到"有修饰"的对象的使用, (如customer.name代替name), 更有语境,更易阅读.
8. 使用controllerAs时, controller中的$scope被绑定到this上.
    避免在controller中使用$scope, 最好不用或是把他们移到factory中,
    factory中可以考虑使用$scope, controller中只在需要的时候才使用$scope,
    例如$emit, $broadcast, 或者$on来发布和订阅事件时, 可以考虑把这些调用挪到factory中,
    并从controller中调用.
9. 使用controllerAs语法时把this赋予一个可以捕获的变量, 选择一个有代表性的名称, 例如vm代表ViewModel
    this在不同的地方有不同的语义(作用域不同), 在container中的一个函数中使用它,
    可能改变上下文, 所以用一个变量来捕获this的上下文从而避免这样的问题.
10. 可绑定成员放在controller的顶部, 并且不要通过controller的代码传播.
    易读, 可以让你立即识别controller中哪些成员可以在View中绑定和使用.
    虽然设置单行匿名函数很容易, 但是当这些函数的代码超过一行时, 这将极大的降低代码的可读性,
    在可绑定成员下面定义函数, 可以把具体的实现细节放在下面, 提高可读性.
11. 函数声明隐藏实现细节. (Y034)
      易读, 与识别哪些成员可以在View中绑定和使用.
      把函数的实现细节放在后面, 你可以跟清楚的看到重要的东西.
      由于函数声明会被提到顶部, 所以你没有必要担心在声明它之前就使用函数的问题.
      你再有不用担心当a依赖于b时, barvar a 放在var b之前会中断你的代码的函数声明问题.
      函数表达式中顺序时至关重要的.
12. 把Controller中的逻辑延迟到Service中, 通过委派到wervice和factory中来延迟controller中的逻辑.
      把逻辑放到service中, 并通过一个function暴露, 就可以被多个controller重用.
      把逻辑放到service中, 使单元测试的时候更加容易把他们分离, 相反就很二...
      保持controller的简介.
      从controller中删除依赖关系并且隐藏实现细节.
13. 保持Controller的专一性.
      一个view定义一个controller, 尽量不要在其他的view中使用这个controller.
      把可重用的逻辑放在factory中, 保证当前的controller只服务于当前的视图.
      不同的view用同一个controller是非常不科学的, 良好的端对端测试覆盖率对于保证大型应用程序,
      的稳定性是必需的.
14. 当一个controller必需匹配一个view或者任何一个组件可能被其他controller,
    或是view重用时, 连同route一起定义.
      在route中匹配controller允许不同的路由调用不同的相匹配的controller和view,
      在view中通过controller分配controller时, 这个view总是和相同的controller相关联.
15. Services.
      用new实例化service, 用this实例化公共方法和变量, 由于这些和factory是类似,
    所以为了统一, 推荐用facotry来代替.
16. Factories.
      factory应该是单一职责, 这是由其上下文进行封装的. 一旦一个factory将要处理超过超过单一的目的时
      就因该创建一个新的factory.
      factory是一个单例, 它返回一个包含service成员的对象.
17. 可访问的成员放在顶部.
    使用从显露模块模式派生出来的技术吧service(它的接口)中可调用的成员暴露到顶部.
    易读, 并且让你可以立即识别service中的哪些成语可以被调用, 哪些必需单元测试, 哪些被嘲笑.
    当文件内容很长时, 这可以避免需要滚动才能看到暴露哪些东西.
18. 把进行数据操作和数据交互的逻辑放到factory中, 数据服务负责XHR请求, 本地储存, 和其他任何数据.
      controller的作用是查看视图和收集视图的信息, 他不应该关心如何取得数据,
      只需要知道哪里需要用到数据, 把取数据的逻辑放到数据服务中能够让controller更简单,
      更专注于view的控制.
      方便测试.
      -数据服务的实现可能有非常明确的代码来处理数据仓库，这可能包含headers、如何与数据交互或是其它service，例如$http。把逻辑封装到单独的数据服务中，这隐藏了外部调用者（例如controller）对数据的直接操作，这样更加容易执行变更。
19. 数据调用返回一个Promise
    就像$http一样, 调用数据时返回一个promise, 在你的调用函数中也返回一个promise.
      你可以把promise链接到一起, 在数据调用完成并且resolve或者reject这个promise后采取进一步行为.
20. Directives,一个dirctive一个文件.
    一个文件中只创建一个directive, 并依照directive来命名文件.
      一个文件一个directive个容易维护.
21. 在directive中操作DOM
     当需要直接操作DOM的时候, 使用directive.
22. 提供一个唯一的Directive前缀.
     提供一个短小, 唯一, 具有描述性的directive前缀.
23. 限制元素和属性.(restrict)
24. Directives和ControllerAs, directive使用controller as语法, 和view使用controller as保持一致.
    因为不难且有必要这样做.
    directive的控制器实在directive外部, 这种风格避免了由于注入造成的return之后的代码无法访问的情况
25. 当directive中使用了controller as语法时, 如果你想把父级作用域绑定到directive的作用域时,
    使用bindToController = true.
    bindToController: true // 应为范围隔离 angular 1.3.0
26. Controller Activation Promises, 在activate函数中解决controller的启动逻辑.
      把启动逻辑放在一个controller中固定位置, 可以方便定位, 有利于保持测试的一致性, 并能够避免controller中到处是激活逻辑.
      activate这个controller使得重用刷新视图的逻辑变得很方便, 把所有的逻辑都放到了一起,
      可以让用户更快的看到视图, 可以轻松的对ng-view或ui-view使用动画, 用户体验更好.
27. Route Resolve Promises---Y081
28. 声明依赖时避免使用缩写手法.
29. 用$inject手动添加Angular组件所需的依赖.
      这种技术反映了使用ng-annotate的技术, 如果ng-annotate检测到已经有了注入, name他就不会再次重复执行.
      可以避免依赖变成Angular找不到的变量, 如common变成a.
      避免创建内嵌的依赖, 因为一个数组太长不利于阅读.
      *当你的函数处于return语句后面, 那么$inject是无法访问的, 你可用通过吧COntroller移到directive外面来解决这个问题.
30. 手动确定路由解析器依赖, 用$inject手动给Angular组件添加路由解析器依赖.
      这种技术打破了路由解析的匿名函数的形式, 易读.
      $inject语句可以让任何依赖都可以安全压缩.
31. ng-annotate依赖注入注释, 可生成依赖注入代码.
32. 使用Gulp或Grunt结合ng-annotate, 可以把/* @ngInject */注入到任何有依赖关系的函数前面.
33. Y110异常处理, 使用一个decoratpr, 在配置的时候用$provide服务, 当发生异常时,
    在$exceptionHandler服务中执行自定义的处理方法.
      在开发时和运行时提供了一种统一的方式来处理未被捕获的Angular异常.
      *另一个选项是用来覆盖service的，这个可以代替decorator，这是一个非常nice的选项，但是如果你想保持默认行为，那么推荐你扩展一个decorator。
34. 创建一个暴露了一个借口的factory来捕获异常并以合适的方式处理异常.
      提供了一个统一的方式来捕获代码中抛出的异常.
35. 命名原则.
      遵循以描述组件功能, 然后是类型的方式给所有的组件提供统一的命名,
      我推荐的做法是feature.type.js.
        文件名(avengers.controller.js)
        带有Angular的注册组件名(AvengersController)
      命名约定有助于为一目了然的找到内容提供的一个统一的方式,
      在项目中和团队中保持统一性是非常重要的.
36. 功能文件命名, 遵循以"描述组件功能.类型"的方式来给所有的组件提供唯一的命名.
      为快速识别组件提供统一的方式.
      为任何自动化的任务提供模式匹配.
37. 测试文件命名, 和组件命名差不多, 带上一个spec后缀.
38. Controller命名, 为所有的controller提供统一的名称, 先特征后名字, 鉴于controller是构造函数, 
    所以要采用每个单词首字母大写的方式命名.
39. Controller使用controller为命名后缀.
40. Factory命名使用驼峰式避免使用$前缀.
      可以快速识别和引用factory.
      避免与内部使用$前缀的服务发生冲突.
41. Directive组件命名, 用一个短的前缀来描述directive在哪个区域使用.
42. 当有很多模块时, 主模块文件命名成app.module.js, 其他依赖模块以他们代表的内容来命名,
    如,一个管理员模块命名成admin.module.js.
43. 把一个模块的配置独立到他自己的文件中, 以这个模块为基础命名.
    app模块的配置文件命名成app.config.js.
      把配置从模块定义, 组件和活跃代码中分离出来.
      为设置模块的配置提供了一个可识别的地方.
44. 把路由的配置独立到单独的文件, 主模块的路由可以使app.route.js.
45. 构建一个可以快速定位（Locate）代码、一目了然地识别（Identify）代码、拥有一个平直（Flattest）的
    结构、尽量（Try）坚持DRY（Don’t Repeat Yourself）的应用程序，其结构应该遵循这4项基本准则。
---当我发现我的的代码结构很恶心的时候，我就重新看看LIFT准则。---
i. 轻松定位代码(L)
ii. 一眼识别代码(I)
iii. 平直的代码结构(层级不要太多)(F)
iv. 尽量保持不要写重复代码(T)

46. Locate更直观, 更简单, 更快捷的定位代码.
    这对于一个项目是非常重要的, 如果一个团队不能快速的找到他们需要的工作文件,
    这将不能使团队足够高效的工作.
47. Identify当你看到一个文件时, 你应该能够立即知道它包含了什么, 代表了什么.
      你花费更少的时间来了解代码代表了什么，并且变得更加高效。如果这意味着你需要更长的名字，那么就这么干吧。文件名一定要具有描述性，保持和文件内容互为一体。避免文件中有多个controller，多个service，甚至是混合的。
48. Flat尽可能长时间地保持一个平直的文件夹结构, 乳沟你的文件层级超过7+, 那么就开始考虑分离.
      没有谁想在一个7级文件夹中寻找一个文件.
49. 坚持DRY, 但不要疯了一样的却牺牲了可读性.
50. 有实施的短期看法和长远的目标, 换句话说, 从小处入手, 带式要记住app的走向.
51. 把定义应用程序总体布局的组件放到layout文件中, 如导航, 内容区等等.(复用)
52. 按功能划分文件夹的结构, 当文件夹包含的文件超过7个, 就考虑新建文件夹.
      开发者可以快速定位代码、快速识别文件代表的意思，结构尽可能平直，没有重复，没有多余名字。
      LIFT指南都包括在内。
      通过组织内容和让它们保持和LIFT指导准则一致，帮助降低应用程序变得混乱的可能性。
      超过10个文件时，在一个一致性的文件夹中很容易定位，但是在一个平直的文件夹结构中确实很难定位
53. 模块化, 许多小的, 独立的模块, 创建只封装一个职责的小模块.
      很容易添加新的功能.
54. 创建一个App Module, 它的职责是吧应用程序中的所有模块和功能都放在一起.
55. 保持App MOdule的精简, 它内部只放聚合其他模块的逻辑, 具体功能在他们自己的模块中实现.
56. 创建代表功能区的模块, 例如布局, 可重用, 共享服务, 仪表盘和app的特殊功能.
      自包含的模块可以五分的被添加到应用程序中.
      项目进行功能迭代时, 可以专注于功能, 在开发完成启用他们即可.
      把功能拆分成不同的模块方便测试.
57. 可重用的块就是模块.
    为通用service创建代表可重用的应用程序模块, 例如异常处理, 日志记录, 诊断, 安全性和本地数据储存等模块.
      这些类型的功能在很多的应用程序中都需要用到, 所以把他们分离到自己的模块中, 他们可以变成通用的应用程序, 也能被跨应用地进行重用.
58. 应用程序根模块依赖于应用程序特定的功能模块, 共享的和可复用的模块.(需要的依赖他就好)
      主程序模块包含一个能快速识别应用程序功能的清单.
      每个功能区都包含一个它依赖了哪些模块的列表, 因此其他应用可以把它当作一个依赖引入进来.
      程序内部的功能, 如共享数据的服务变得更容易定位, 并且从app.core中共享.
      但是心中一定要记得保持一致性、可维护性和效率。
59. 启动逻辑.
      必须在angular应用启动前进行配置才能把代码注入到模块配置,
      理想的一些case应该包含providers和constants.
        这使得在更少的地方进行配置变得容易.
60. 运行代码块, 任何在应用程序启动时需要运行的代码都应该在factory中声明, 通过一个function暴露出来,
    然后注入到运行代码块中.
    直接在运行代码块处写代码将会使测试变成很困难, 相反, 如果放到facotry则会使的抽象和模拟变得很简单.
61. 使用Angular $包装的服务, 使用内部包装服务将更容易测试.
62. 单元测试有助于保持代码的清晰!!!
63. 用故事来编写测试, 给每一个故事都写一组测试, 先创建一个空的测试, 然后用你给这个故事的代码填充它
      编写测试有助于明确规定你的故事要做什么, 不做什么以及你如何判断是否成功.
64. 用Jasmine或者Mocha进行单元测试. (测试库)
65. Karma. (测试运行器)
67. 组织测试, 把单元测试的文件放到一个独立的tests文件夹中, 他和你的客户端代码并列.
      单元测试和源代码中的每一个组件和文件都有直接的想关心.
      这样它就会一直在你的视野中, 很容易让他们保持在最新的状态.
      更新源代码的时候可以更简单地在同一时间更新测试代码.
      方便源码阅读者了解组件如何使用, 也便于发现其中的局限性.
      方便找, 方便使用grunt或者gulp.
68. 动画, 用法, 在页面过度时使用Angular动画, 包括ngAnimate模块, 关键点时细微, 平滑, 无缝.
      提高用户体验, 当时图过度时, 微小的动画可以提高感知性.
69. 使用animate.css, 提供一致性.
70. 那么使用jsDoc的语法记录函数名, 描述, 参数和返回值.
    使用@namespace和@memberOf来匹配应用程序结构.
      可以生成文档, 而不必从头开始编写文档.
      使用业内通用工具保持了统一性.
71. 对于一些不需要变动,也不需要从其他service中获取的只, 使用常量定义,  
    当一些常量只是在一个模块中使用但是有可能会在其他应用中使用的话, 
    把他们写到一个以当前模块命名的文件中. 把常量集合到一起是非常有必要的.
    你可以把他们写到constants.js的文件中.
      一个可能变化的值, 及时变动的很少, 也会从service中重新检索, 因此你不需要修改源代码.
      常量可以被注入到任何angular组件中, 包括providers.

