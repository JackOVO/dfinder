current 当前
original 原文
Complete 完成,完全
Failed 失败
1. 单一职责 - 一个文件只定义一个组件.
2. 把Angular组件包装到一个立即调用的函数表达式中(IIFE).
    把变量从全局作用域中删除, 防止更长的生命周期, 避免冲突, 和压缩合并冲突问题.
3. 避免命名冲突, 每一个独立的子模块使用唯一的命名约定.
4. 不适用任何一个是用来setter语法的变量定义modules. //?
5. 使用module的时候, 避免直接用一个变量, 而是使用getter链式语法.
    这将产生更加易读的代码, 并且可以避免变量冲突和泄露.
6. 回调函数使用命名函数, 不要使用匿名函数.
    易读, 方便调试, 减少嵌套回调函数的数量.
7. 使用containerAs语法代替直接用的$scope定义的controller的方法.
    congtroller被构建的时候, 就会有一个新的实例, controllerAs语法跟接近JavaScript构造函数.
    这促进在View中对绑定到"有修饰"的对象的使用, (如customer.name代替name), 更有语境,更易阅读.
8. 使用controllerAs时, controller中的$scope被绑定到this上.
    避免在controller中使用$scope, 最好不用或是把他们移到factory中,
    factory中可以考虑使用$scope, controller中只在需要的时候才使用$scope,
    例如$emit, $broadcast, 或者$on来发布和订阅事件时, 可以考虑把这些调用挪到factory中,
    并从controller中调用.
9. 使用controllerAs语法时把this赋予一个可以捕获的变量, 选择一个有代表性的名称, 例如vm代表ViewModel
    this在不同的地方有不同的语义(作用域不同), 在container中的一个函数中使用它,
    可能改变上下文, 所以用一个变量来捕获this的上下文从而避免这样的问题.
10. 可绑定成员放在controller的顶部, 并且不要通过controller的代码传播.
    易读, 可以让你立即识别controller中哪些成员可以在View中绑定和使用.
    虽然设置单行匿名函数很容易, 但是当这些函数的代码超过一行时, 这将极大的降低代码的可读性,
    在可绑定成员下面定义函数, 可以把具体的实现细节放在下面, 提高可读性.
11. 函数声明隐藏实现细节. (Y034)
      易读, 与识别哪些成员可以在View中绑定和使用.
      把函数的实现细节放在后面, 你可以跟清楚的看到重要的东西.
      由于函数声明会被提到顶部, 所以你没有必要担心在声明它之前就使用函数的问题.
      你再有不用担心当a依赖于b时, barvar a 放在var b之前会中断你的代码的函数声明问题.
      函数表达式中顺序时至关重要的.
12. 把Controller中的逻辑延迟到Service中, 通过委派到wervice和factory中来延迟controller中的逻辑.
      把逻辑放到service中, 并通过一个function暴露, 就可以被多个controller重用.
      把逻辑放到service中, 使单元测试的时候更加容易把他们分离, 相反就很二...
      保持controller的简介.
      从controller中删除依赖关系并且隐藏实现细节.
13. 保持Controller的专一性.
      一个view定义一个controller, 尽量不要在其他的view中使用这个controller.
      把可重用的逻辑放在factory中, 保证当前的controller只服务于当前的视图.
      不同的view用同一个controller是非常不科学的, 良好的端对端测试覆盖率对于保证大型应用程序,
      的稳定性是必需的.
14. 当一个controller必需匹配一个view或者任何一个组件可能被其他controller,
    或是view重用时, 连同route一起定义.
      在route中匹配controller允许不同的路由调用不同的相匹配的controller和view,
      在view中通过controller分配controller时, 这个view总是和相同的controller相关联.
15. Services.
      用new实例化service, 用this实例化公共方法和变量, 由于这些和factory是类似,
    所以为了统一, 推荐用facotry来代替.
16. Factories.
      factory应该是单一职责, 这是由其上下文进行封装的. 一旦一个factory将要处理超过超过单一的目的时
      就因该创建一个新的factory.
      factory是一个单例, 它返回一个包含service成员的对象.
17. 可访问的成员放在顶部.
    使用从显露模块模式派生出来的技术吧service(它的接口)中可调用的成员暴露到顶部.
    易读, 并且让你可以立即识别service中的哪些成语可以被调用, 哪些必需单元测试, 哪些被嘲笑.
    当文件内容很长时, 这可以避免需要滚动才能看到暴露哪些东西.
18. 把进行数据操作和数据交互的逻辑放到factory中, 数据服务负责XHR请求, 本地储存, 和其他任何数据.
      controller的作用是查看视图和收集视图的信息, 他不应该关心如何取得数据,
      只需要知道哪里需要用到数据, 把取数据的逻辑放到数据服务中能够让controller更简单,
      更专注于view的控制.
      方便测试.
      -数据服务的实现可能有非常明确的代码来处理数据仓库，这可能包含headers、如何与数据交互或是其它service，例如$http。把逻辑封装到单独的数据服务中，这隐藏了外部调用者（例如controller）对数据的直接操作，这样更加容易执行变更。
19. 数据调用返回一个Promise
    就像$http一样, 调用数据时返回一个promise, 在你的调用函数中也返回一个promise.
      你可以把promise链接到一起, 在数据调用完成并且resolve或者reject这个promise后采取进一步行为.
20. Directives,一个dirctive一个文件.
    一个文件中只创建一个directive, 并依照directive来命名文件.
      一个文件一个directive个容易维护.
21. 在directive中操作DOM
     当需要直接操作DOM的时候, 使用directive.
22. 提供一个唯一的Directive前缀.
     提供一个短小, 唯一, 具有描述性的directive前缀.
23. 限制元素和属性.(restrict)
Y073-----
